---
title: 每周一文
tags: 腾讯云
categories: 每周一文
date: 2023-12-20 11:39:22
---

### 前言

总结开发中遇到的思路，方法

### SWR优化网页体验

[SWR](https://swr.vercel.app/zh-CN) 

SWR 是用于数据请求的 React Hooks 库；

“SWR” 这个名字来自于 stale-while-revalidate：一种由 HTTP RFC 5861(opens in a new tab) 推广的 HTTP 缓存失效策略。这种策略首先从缓存中返回数据（过期的），同时发送 fetch 请求（重新验证），最后得到最新数据。

使用 SWR，组件将会不断地、自动获得最新数据流。
UI 也会一直保持快速响应。

```js

import { SWRConfig } from "swr";

function App() {
  return (
    // 全局禁用焦点重新验证 + 禁用错误自动重试
    <SWRConfig value={{ revalidateOnFocus: false, errorRetryCount: 0 }}>
      <YourComponent />
    </SWRConfig>
  );
}

```

1. revalidateOnFocus: false
默认行为：当浏览器窗口重新获得焦点（如用户切换回标签页）时，SWR 会自动触发数据的重新验证（重新请求数据）。

设置作用：禁用焦点触发重新验证，避免不必要的网络请求。适用于：

数据更新频率要求不高的场景（如静态数据）

减少对后端的压力

防止页面闪烁（频繁数据刷新）

2. errorRetryCount: 0
默认行为：SWR 在请求失败时会自动重试（默认重试 3 次），每次重试间隔按指数退避算法递增。

设置作用：禁用错误自动重试机制，使请求失败后立即停止重试。适用于：

需要快速反馈错误（如显示错误提示）

避免因服务不可用导致的无限重试（如 404 错误）

手动控制重试逻辑（如用户点击“重试”按钮）

- 通过合理配置 <SWRConfig>，可以显著优化应用的网络请求行为和用户体验。

### 优化体验

1. <SWRConfig>配置，如上文

2. React.Suspense



### npm包开发-软链


1. 背景

最近在打通全链路监控，前端方面依赖腾讯云自研的sdk实现前端监控，有部分需求要和apm合作，进行sdk的修改，sdk的修改不同于一般项目，它是一个npm包，在本地开发测试npm包，需要用到软链


2. 什么是软链

简单说就是为开发的模块(待发布的npm包)创造一个全局链接，在主项目里链接这个依赖的模块，进行测试。

3. 如何创建、使用软链

SDK 开发需要将本地代码代理到用户项目或者页面中，这里有两种方式

1. 如果用户页面使用 cdn 模式

SDK项目启动后，可以使用 whistle 把 cdn 地址代理到本地，代理地址

```sh
tam.cdn-go.cn/aegis-sdk/latest/aegis.min.js [project_path]/aegis-sdk/packages/web-sdk/lib/aegis.js
```

2. 如果用户项目使用 npm 包

项目启动后，cd 到 packages/web-sdk，在控制台执行

```sh
npm link  
```

创建一个全局的链接，npm link作用在本地目录中创建一个符号链接，将一个包与依赖该包的项目之间建立关联。这样可以在本地工作在一个包上，而无需将其发布到注册表中。

在需要调试的项目中执行
```sh
npm link packageName
npm link @tencent/aegis-web-sdk // 例如腾讯云监控包
```
注意：这里的packageName一定要对应你的npm包package.json里的name字段值。 


通过上边两步，我们已经可以在主项目里使用位于本地的npm包开发测试了


4. 去除软链

```sh
npm unlink
npm link packageName
```

5. 查看所有创建的全局链接名称

```sh
npm ls --global --depth 0
```



### 事件循环以及微宏任务

一文彻底厘清js事件循环和微任务、宏任务

浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 事件循环 的。

理解事件循环的工作方式对于代码优化很重要，有时对于正确的架构也很重要。

事件循环
事件循环 的概念非常简单。它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。

引擎的一般算法：

当有任务时：
从最先进入的任务开始执行。
休眠直到出现任务，然后转到第 1 步。
当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。

任务示例：

当外部脚本 <script src="..."> 加载完成时，任务就是执行它。
当用户移动鼠标时，任务就是派生出 mousemove 事件和执行处理程序。
当安排的（scheduled）setTimeout 时间到达时，任务就是执行其回调。
……诸如此类。
设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。

一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。

多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）：

例如，当引擎正在忙于执行一段 script 时，用户可能会移动鼠标而产生 mousemove 事件，setTimeout 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。

队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 script 后，它会处理 mousemove 事件，然后处理 setTimeout 处理程序，依此类推。

到目前为止，很简单，对吧？

两个细节：

引擎执行任务时永远不会进行渲染（render）。如果任务执行需要很长一段时间也没关系。仅在任务完成后才会绘制对 DOM 的更改。
如果一项任务执行花费的时间过长，浏览器将无法执行其他任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议你终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。
以上是理论知识。现在，让我们来看看如何应用这些知识。

用例 1：拆分 CPU 过载任务
假设我们有一个 CPU 过载任务。

例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。

当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。

我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 setTimeout（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推。

为了演示这种方法，简单起见，让我们写一个从 1 数到 1000000000 的函数，而不写文本高亮。

如果你运行下面这段代码，你会看到引擎会“挂起”一段时间。对于服务端 JS 来说这显而易见，并且如果你在浏览器中运行它，尝试点击页面上其他按钮时，你会发现在计数结束之前不会处理其他事件。

```js

let i = 0;

let start = Date.now();

function count() {

  // 做一个繁重的任务
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();
```

浏览器甚至可能会显示一个“脚本执行时间过长”的警告。

让我们使用嵌套的 setTimeout 调用来拆分这个任务：

```js
let i = 0;

let start = Date.now();

function count() {

  // 做繁重的任务的一部分 (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // 安排（schedule）新的调用 (**)
  }

}

count();

```

现在，浏览器界面在“计数”过程中可以正常使用。

单次执行 count 会完成工作 (*) 的一部分，然后根据需要重新安排（schedule）自身的执行 (**)：

首先执行计数：i=1...1000000。
然后执行计数：i=1000001..2000000。
……以此类推。
现在，如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 onclick 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 count 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。

值得注意的是这两种变体 —— 是否使用了 setTimeout 对任务进行拆分 —— 在执行速度上是相当的。在执行计数的总耗时上没有多少差异。

为了使两者耗时更接近，让我们来做一个改进。

我们将要把调度（scheduling）移动到 count() 的开头：

```js 

let i = 0;

let start = Date.now();

function count() {

  // 将调度（scheduling）移动到开头
  if (i < 1e9 - 1e6) {
    setTimeout(count); // 安排（schedule）新的调用
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();

```

现在，当我们开始调用 count() 时，会看到我们需要对 count() 进行更多调用，我们就会在工作前立即安排（schedule）它。

如果你运行它，你很容易注意到它花费的时间明显减少了。

为什么？

这很简单：你应该还记得，多个嵌套的 setTimeout 调用在浏览器中的最小延迟为 4ms。即使我们设置了 0，但还是 4ms（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。

最后，我们将一个繁重的任务拆分成了几部分，现在它不会阻塞用户界面了。而且其总耗时并不会长很多。

用例 2：进度指示
对浏览器脚本中的过载型任务进行拆分的另一个好处是，我们可以显示进度指示。

正如前面所提到的，仅在当前运行的任务完成后，才会对 DOM 中的更改进行绘制，无论这个任务运行花费了多长时间。

从一方面讲，这非常好，因为我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容。很重要，对吧？

这是一个示例，对 i 的更改在该函数完成前不会显示出来，所以我们将只会看到最后的值：


```js 


<div id="progress"></div>

<script>

  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>

```
……但是我们也可能想在任务执行期间展示一些东西，例如进度条。

如果我们使用 setTimeout 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。

这看起来更好看：


```js 
<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // 做繁重的任务的一部分 (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }

  }

  count();
</script>

```

现在 div 显示了 i 的值的增长，这就是进度条的一种。

用例 3：在事件之后做一些事情
在事件处理程序中，我们可能会决定推迟某些行为，直到事件冒泡并在所有级别上得到处理后。我们可以通过将该代码包装到零延迟的 setTimeout 中来做到这一点。

在 创建自定义事件 一章中，我们看到过这样一个例子：自定义事件 menu-open 被在 setTimeout 中分派（dispatched），所以它在 click 事件被处理完成之后发生。

```js 
menu.onclick = function() {
  // ...

  // 创建一个具有被点击的菜单项的数据的自定义事件
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // 异步分派（dispatch）自定义事件
  setTimeout(() => menu.dispatchEvent(customEvent));
};

```

宏任务和微任务
除了本章中所讲的 宏任务（macrotask） 外，还有在 微任务（Microtask） 一章中提到的 微任务（microtask）。

微任务仅来自于我们的代码。它们通常是由 promise 创建的：对 .then/catch/finally 处理程序的执行会成为微任务。微任务也被用于 await 的“幕后”，因为它是 promise 处理的另一种形式。

还有一个特殊的函数 queueMicrotask(func)，它对 func 进行排队，以在微任务队列中执行。

每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。

例如，看看下面这个示例：

https://zh.javascript.info/event-loop#yong-li-1-chai-fen-cpu-guo-zai-ren-wu




### http2.0与1.0的分析

- 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合，基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
- header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
- 服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了
// 通过在应用生成HTTP响应头信息中设置Link命令 Link: </styles.css>; rel=preload; as=style, </example.png>; rel=preload; as=image

- 多路复用（MultiPlexing）

- HTTP/1.0 每次请求响应，建立一个TCP连接，用完关闭 - HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； - HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；


### JS中的一些操作符

1. ??  “空值合并运算符”（nullish coalescing operator）。它用于返回其左侧操作数，除非该操作数是 `null` 或 `undefined`，在这种情况下，它返回右侧操作数。
例如：
```javascript
let value = someVariable ?? defaultValue;
```
如果 `someVariable` 是 `null` 或 `undefined`，则 `value` 将被赋值为 `defaultValue`；否则，将赋值为 `someVariable`。


### UDT和TCP的差异


- TCP：面向连接、可靠性、顺序保证、流量机制、拥塞机制

工作机制： 三次握手、四次挥手、分包传输、流量拥塞控制

三次握手： 客户端 - SYN - 服务器； 服务器 - SYN + ACK - 客户端； 客户端 - ACK - 服务端
四次挥手： 发起方 - FIN - 接收方； 接收方 - ACK- 发送包；在重复一次。
数据传输：分包传输数据，每个包有序列号，接收方通过应答接受数据包，来确认顺序和丢包情况；


- UDP： 更简单；不提供可靠性和连接性；试用于传输实时性高，不需要可靠传输的场景；
无连接性、快速、低延迟、广播和多播；

工作机制： 数据封装、数据传输、数据接收；


- 区别：
- UDP： 都是传输层协议 


七层协议： 应用层、表示层、会话层、 传输层、网络层、数据链路层、物理层；


### 事件循环机制详解

- 核心概念
JavaScript 的事件循环(Event Loop)是其实现异步编程的核心机制，它使得单线程的 JavaScript 能够处理非阻塞I/O操作。事件循环由以下几个关键部分组成：

 - 调用栈(Call Stack)：同步代码的执行场所，遵循LIFO(后进先出)原则

 - 任务队列(Task Queue)：存放异步任务的回调函数

 - 微任务队列(Microtask Queue)：存放优先级更高的异步任务回调

 - 事件循环线程：负责监控调用栈和任务队列

- 事件循环的工作流程
1. 执行同步代码：

 - 所有同步代码在主线程上依次执行，形成调用栈

 - 遇到异步API调用时，将其交给Web APIs处理

2. 处理异步任务：

 - 宏任务(setTimeout等)完成后，回调进入宏任务队列

 - 微任务(Promise等)完成后，回调进入微任务队列

3. 事件循环步骤：

 - 执行当前宏任务(从宏任务队列取出)

 - 执行所有微任务(清空微任务队列)

 - 必要时进行UI渲染

 - 重复上述过程

- 任务类型与优先级
任务类型	示例	优先级	执行时机
同步任务	console.log()	最高	立即执行
微任务	Promise.then()、MutationObserver、queueMicrotask()	高	当前宏任务结束后立即执行
宏任务	setTimeout()、setInterval()、I/O、UI渲染	低	下一次事件循环

#### 特殊场景分析

1. 微任务嵌套
每个微任务执行时产生的新微任务会在当前批次中执行，不会留到下次事件循环
```js
/**
 * 
 * 执行顺序： 
 * 微任务1
 * 嵌套微任务
 * 微任务2
 */
Promise.resolve().then(() => {
  console.log('微任务1');
  Promise.resolve().then(() => {
    console.log('嵌套微任务');
  });
}).then(() => {
  console.log('微任务2');
});
```
2. 宏任务中的微任务
```js
/**
 * 
 * 微任务
 * 宏任务
 * 宏任务中的微任务
 */
setTimeout(() => {
  console.log('宏任务');
  Promise.resolve().then(() => {
    console.log('宏任务中的微任务');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('微任务');
});

```

实际应用注意事项
避免微任务饥饿：不要在微任务中无限添加微任务，否则会阻塞主线程

性能考量：

微任务适合高优先级小任务

宏任务适合耗时较长的任务

Node.js差异：

Node中有process.nextTick(优先级高于Promise)

有setImmediate(特殊类型的宏任务)