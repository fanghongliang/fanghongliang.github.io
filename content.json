{"meta":{"title":"Fanghongliang's blog","subtitle":null,"description":"站在巨人的肩膀上","author":"fanghl","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-19T07:11:42.000Z","updated":"2019-08-19T07:14:52.444Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python与JavaScript对照学习总结点","slug":"learnPython","date":"2019-08-30T08:54:46.460Z","updated":"2019-08-30T09:39:22.959Z","comments":true,"path":"2019/08/30/learnPython/","link":"","permalink":"http://yoursite.com/2019/08/30/learnPython/","excerpt":"","text":"Python与JavaScript对照学习总结点Python： 廖雪峰-Python传送门： https://www.liaoxuefeng.com/wiki/1016959663602400begin：…..Go 命令行打开 .py 文件；Python交互环境，执行Python代码 缩进方式进行代码格式！！4格空格缩进大小写敏感 数据类型： 整数 浮点数 字符串 布尔值 =》 and, or, not 空值 None 列表 字典 变量：1.常量，即不能变的变量，指针指向不变 类const，常量一般为变量名全部大写 除法： / 浮点数除法，即便是两个整数相除，结果也是浮点数 // 地板除，两个整数的除法仍然是整数，结果只取整数 10 // 3 =》 3 % 求模取余 字符串编码： ord() 数获取字符的整数表示 chr() 函数把编码转换为对应的字符Python的字符串类型是str，在内存中以Unicode表示Python对bytes类型的数据用带b前缀的单引号或双引号表示 x = b’abc’ encode() 方法可以编码为指定的bytes decode() 方法 把bytes变为str如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节： b’\\xe4\\xb8\\xad\\xff’.decode(‘utf-8’, errors=’ignore’) len() 方法计算str的字符数1个中文字符经过UTF-8编码占用3个字节，而1个英文字符只占用1个字节。 坚持 utf-8 编码 文件开头写上： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 格式化： Python与C一致，都采用 % 实现%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换&#39;age: %s. nmae: %s&#39; %(25, fhl) format() 格式化，比较麻烦 list 和 tuple : list : 列表。类数组 Arrayclassmates = [&#39;xaioming&#39;, &#39;xiaohua&#39;, &#39;xiaoliu&#39;]获取最后一个元素 classmates[len(classmates) - 1] 或者 classmates[-1] list 方法：append(content) 末尾插入insert(index, content) 插入指定位置pop() 删除末尾元素pop(index) 删除指定位置元素 tuple 元组，有序列表一旦初始化，不能更改。没有append、insert方法，其他和list一致因为不能更改，故更为安全，能用tuple代替list就尽量用tuple！t = (1,)t = (&#39;str&#39;, 23, [&#39;a&#39;]) 条件判断: 123456if age &gt;= 18: print('成年人')elif age &gt;= 1: print('幼儿期')else: print('婴儿期') int() 转化为整数函数 循环： for…in循环 while 循环 range() 生成一个整数序列,再通过list()函数可以转换为list break 退出循环 配合if使用 continue 跳过循环 配合if使用 使用dict和set：dictionary字典，其他语言叫map，使用key-value存储，也就是js的对象。json的话，本质是字符串，也可以类比吧。d = {&#39;name&#39;: &#39;fhl&#39;, &#39;age&#39;: 22, }PS: 区别点： js的对象可以使用 . 方法调用，Python目前只能 d[‘age’]或者 d.get(‘age’,-1)获取存储的值删除一个key，可以用 pop(key)dictionary是空间换时间的方法，list时间换空间 set：同js中的key同根同源，存储key的集合,不存储value，且key不重复！！！创建set，需要一个list作为输入集合 add(key) 添加元素到set中，重复添加不会有效果 remove(key) 删除元素 set可看做成无序、无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等1234s1 = set([1, 3, 54])s2 = set([2, 3, 4])s1 &amp; s2 # 并 ，单个&amp; s1 | s2 # | 或，单个| 函数：自带函数（内置函数）： abs() 、max()数据类型转换函数： int() float() str() bool() 参考js的数据转换函数 String() Number() Boolean() 定义函数：关键字： def, 依次写出函数名、括号、括号中的参数和冒号:,然后，在缩进块中编写函数体，函数的返回值用return语句返回类比js: 关键字function ，后面都一致，然后把 冒号 换成 js中的 大括号 即可 def my_abs(num): if x &gt;= 10: return x else: return -x 执行函数： 相比于Python，js的函数执行比较简单，定义完函数后，直接用函数名字加一堆小括号就可以调用当前函数，但Python貌似得先导入该函数，才可以调用 from test import my_abs my_abs(-1) pass关键字pass语句啥都不做，就和0一样，用来占位的。让程序可以跑起来。可以理解为斗地主时，你的牌大不过上家的，你就可以大吼一声： pass/过，让单线程的斗地主可以走下去，而不至于卡在这里，让队友喷你 Python函数返回值js函数没有return语句时，返回的是 undefined。Python返回的是 None，在存在返回多个值的情况下。Python返回的是tuple，一个tuple可以被好多个变量接收，具体场景参考ES6的解构赋值，一毛一样。 默认参数没啥好讲的，和ES6函数默认参数一毛一样，默认参数在后，必填参数在前 可变参数参数前面添加 * ，在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数，有点意思奥,即便我们的传参是list或者tuple，也可以在参数前加 * ，使得list或者 tuple 变为可变参数传进去 关键字参数 **ky可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求 def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 总结： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 递归函数： 尾递归优化def fact(n): if n==1: return 1 return n * fact(n - 1) 以上代码是Python的递归代码，额，可能耦合性较高，函数内部使用了当前函数的名字，这高度耦合，在js里面我们可以通过 arguments.callee解决调用自身的问题，减小耦合。以下是js代码： function fact(n) { if( n == 1 ) { return 1 } return n * arguments.callee(n-1) } 高级特性： …持续更新…….","categories":[],"tags":[]},{"title":"七月份项目自我总结","slug":"summary201907","date":"2019-08-27T07:58:55.819Z","updated":"2019-08-30T09:49:11.320Z","comments":true,"path":"2019/08/27/summary201907/","link":"","permalink":"http://yoursite.com/2019/08/27/summary201907/","excerpt":"","text":"七月份项目自我总结小程序： 相亲小红圈+tool： wepy 传送门：[ wepy ] https://tencent.github.io/wepy/document.html#/[ Vue ] https://cn.vuejs.org/[ ES6 ] http://es6.ruanyifeng.com/[ git ] https://www.liaoxuefeng.com/ 七月份结束，项目上线，回过头来整理一下项目，项目为wepy1.7.0后版本开发的小程序，配套的后台前端使用ant-design-vue开发，上传测试服工具使用Xshell6。简介 wepy构建工程 目录 定时器 组件传值 三层组件，点击事件传播 token验证 formID 支付 图片上传 微信消息聊天布局 CSS注意点 async/await ios/android机型区别 content简介 wepy构建工程具体可在wepy官网中查看，此处不多介绍。 1234$ wepy init standard my-project /**创建项目*/$ cd my-project /*进入项目目录*/$ npm install /**安装依赖*/$ wepy build --watch /*运行工程并监控项目修改自动刷新*/ 1wepy属于类Vue写法，要在wepy中使用异步操作（async/await）需要在工程的app.way入口文件中constructor函数中注册: 12345constructor () &#123; super() this.use('requestfix') this.use('promisify') /*←手动添加这个*/&#125; 版本更新代码，一般较为固定，直接复制在 onLaunch 生命周期内 123456789101112131415161718192021222324if(wx.canIUse('getUpdateManager'))&#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; if(res.hasUpdate)&#123; updateManager.onUpdateReady((res) =&gt; &#123; wx.showModal(&#123; title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) &#123; if(res.confirm)&#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: '已经有新版本了哟~', content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~' &#125;) &#125;) &#125; &#125;)&#125; content目录 定时器页面业务逻辑有需要用到倒计时功能，如下图。 在页面中有需要用到倒计时或者其他定时器任务时，新建的定时器在卸载页面时一定要清除掉，有时候页面可能不止一个定时器需求，在卸载页面（onUnload钩子函数）的时候一定要清除掉当前不用的定时器定时器用来做倒计时效果也不错，初始时间后台获取，前端处理，后台直接在数据库查询拿到的标准时间（数据库原始时间，T分割），前端需要正则处理一下这个时间： 123456let overTimeStr = data.over_time.split('T')let time1 = overTimeStr[0].replace(/-/g,\",\")let time2 = overTimeStr[1].replace(/:/g,',')let overTime = time1+ ',' + time2let overTimeArr = overTime.split(',')this.countDownCtrl( overTimeArr, 0 ); 最终把时间分割为[年，月， 日， 时， 分， 秒]的数组，（如果后端已经把时间处理过了那就更好了），然后把该数组传递给倒计时函数 123456789101112131415161718192021222324252627282930313233countDownCtrl( time, group ) &#123; let deadline = new Date()//免费截止时间，月的下从0开始 deadline.setFullYear(time[0], time[1]-1, time[2]) deadline.setHours(time[3], time[4], time[5]) let curTimeJudge = new Date().getTime() let timeJudge = deadline.getTime()-curTimeJudge let remainTimeJudge = parseInt(timeJudge/1000) if( remainTimeJudge &lt; 0) &#123; log('倒计时已经过期') return; &#125; this.interva1 = setInterval(() =&gt; &#123; let curTime = new Date().getTime() let time = deadline.getTime()-curTime //剩余毫秒数 let remainTime = parseInt(time/1000) //总的剩余时间,以秒计 let day = parseInt( remainTime/(24*3600) )//剩余天 let hour = parseInt( (remainTime-day*24*3600)/3600 )//剩余小时 let minute = parseInt((remainTime-day*24*3600-hour*3600)/60)//剩余分钟 let sec = parseInt(remainTime%60)//剩余秒 hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute : minute sec = sec &lt; 10 ? '0' + sec : sec let countDownText = hour+ \":\" +minute+ \":\" +sec if( group === 0) &#123; //个人业务逻辑，因为一个页面有两个倒计时需求，代码复用区分 this.countDown = countDownText; &#125; else if( group === 1 ) &#123; this.countDownGroup = countDownText &#125; this.$apply() &#125;, 1000 ); &#125; 至此，倒计时效果处理完毕，PS：终止时间一定要大于currentDate，否则显示会出现异常（包括但不限于倒计时闪烁、乱码等） 最后，退出该页面去其他页面时，一定要在页码卸载钩子中清除倒计时！！！ 123onUnload() &#123; clearInterval(this.interva1);&#125; 组件传值组件传值和Vue有点细微区别，Vue强调父组件的数组和对象不要直接传到子组件使用，应为子组件可能会修改这个data，如图： 但是，wepy中，有时候确实需要把一个对象传递到子组件使用，单个传递对象属性过于繁琐，而且！！！如果单个传递对象的属性到子组件，如果该属性是一个数组，则子组件永远会接收到 undefined 。此时最好用整个对象传值替代单个对象属性逐个传值的方法，且一定要在传值时加入 .sync 修饰符，双向传值绑定。确保从接口拿到的数据也能实时传递到子组件，而非 undefined :circleMembersList.sync=&quot;circleMembersList&quot; 阻止组件的点击事件传播 解决： 添加函数 catchtap=”funcName” 即可，funcName可为空函数，也可以直接不写 token判断小程序调试时，有时候会出现首次打开无内容（拿不到数据）的状态，需要“杀死”小程序再打开才能看到数据内容，其中可能的原因之一便是 token 的失效。在与后台交互的时候，token必不可少。尤其是在小程序分享出去的链接，由其他用户点开分享链接进入小程序内部，此时更是要判断token，token的判断一般选在 onShow（）钩子执行而不在 onLoad（）钩子内执行。若不存在token，则应该执行登录去拿取token，再进行业务逻辑 1234567891011onShow() &#123; const that = this; if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) &#125; &#125;); &#125; &#125; formid微信提供了服务通知，即在你支付、快递等行为时，微信会直接给你发一个服务通知（模板消息）来提醒，每次提醒都会消耗该用户存储的formID，formID为消耗品，用一个少一个，只有通过用户的表单提交行为才可以积攒formID 12345678&lt;form @submit=\"submitForm\" report-submit=\"true\"&gt; &lt;button form-type=\"submit\" class=\"editCard\" @tap = \"goModifiPage('editFormTab')\"&gt;修改&lt;/button&gt;&lt;/form&gt;//js方法submitForm(e) &#123; this.postFormId( e.detail.formId ) // 向后端传输formid&#125; 支付准备： crypto-js.js &amp;&amp; md5.js微信支付流程为： 前端点击支付按钮拉起支付 ==》 准备加密数据 ==》 调用后端接口，传入需要的加密数据 ==》 后端验证加密数据，再返回加密数据 ==》 前端拿到后端加密数据（时间戳、内容、签名），对时间戳和内容进行本地签名，再判断本地签名和后端签名是否一致，若不一致，直接返回，退出支付，支付失败！若一致，对刚刚后台返回的content（内容）进行解析，拿到所需订单数据，前端拉起微信支付，参数传入刚刚解析数据 ===》 得到支付结果 success or fail ！结束 12345678/** * 签名函数 Sign */function sign(timestamp, content) &#123; var raw = timestamp + salt + content var hash = CryptoJS.SHA256(raw).toString() return CryptoJS.MD5(hash).toString()&#125; 前端点击支付按钮： 123456789101112131415161718192021222324252627// 单独支付接口alonePay(arg) &#123; const that = this; if( that.buttonClicked === false ) return; //防止重复多次拉起支付 that.buttonClicked = false; let mode = 1; //业务需求，我有五种不同模式支付 let appId = this.$parent.globalData.appId; let content; let sign; const timeStamp = new Date().Format(\"yyyy-MM-dd hh:mm:ss\").toString(); let code = wepy.getStorageSync('code'); wepy.login().then((res) =&gt; &#123; //获取最新的code，可能这里没必要，具体和后端商量 if(res.code) &#123; let code = res.code; log('code', code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;).then( res =&gt; &#123; content = `mode=$&#123;mode&#125;&amp;app_id=$&#123;appId&#125;` sign = Sign.sign(timeStamp,content); &#125;).then(res =&gt; &#123; that.goCirclePay( that.circle_id, timeStamp, sign, content, mode ) &#125;)&#125;, 支付函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 支付函数，我前端有五种支付情况（单独、自己发起拼团、拼别人团、ios、免费五种支付），所以单独抽出支付，每次调用支付函数goCirclePay( circle_id, timestamp, sign, content, mode) &#123; const that = this; circleApi.goCirclePay(&#123; data: &#123; circle_id, timestamp, sign, content &#125;, getToken: true &#125;).then( res =&gt; &#123; log('支付res：', res) let data = res.data const SignServer = data.sign const timeStampServer = data.timestamp let contentServer = data.content const SignLocal = Sign.sign(timeStampServer,contentServer); if( mode === 0 &amp;&amp; data.status === \"success\") &#123; that.nav('/pages/circleDetail?circle_id=' + that.circle_id) return; &#125; if( SignLocal !== SignServer ) &#123; log('签名不一致！') wx.showToast(&#123; title: \"您已经支付过了\", duration: 1500, image: \"../images/common/icon_wxchat.png\", &#125;) return &#125; let contentArr = contentServer.split('&amp;') const timeStamp = contentArr[0].split('=')[1]; const nonceStr = contentArr[1].split('=')[1]; let index = contentArr[2].indexOf(\"=\"); const package1 = contentArr[2].slice(index+1) const signType = contentArr[3].split('=')[1]; const paySign = contentArr[4].split('=')[1]; wepy.requestPayment(&#123; timeStamp, nonceStr, package: package1, signType, paySign &#125;).then(res =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;) &#125;).then(res =&gt; &#123; //支付后promise，这里有成功和fail两种，fail在catch捕获，这里直接开始写支付success后的业务代码 that.buttonClicked = true; let groupFormIdGet; circleApi.getGroupFormId(&#123; ////获取getGroupFormId data: &#123; circle_id: that.circle_id &#125;, getToken: true &#125;).then( res =&gt; &#123; // let data = res.data that.group_form_id = data.group_form_id groupFormIdGet = data.group_form_id if( mode === 1) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;shareLink=$&#123;that.shareLink&#125;`) &#125; else if( mode === 2) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;group_form_id=$&#123;groupFormIdGet&#125;`) &#125; that.$apply() //脏值检查触发 &#125;) &#125;).catch(res =&gt; &#123; log('支付失败', res) that.buttonClicked = true; &#125;) &#125;)&#125; 图片上传（七牛云）更多图床网站请见我博客： https://www.cnblogs.com/fanghl/p/11419914.html图片上传服务器采用七牛云服务，在app.wpy内小程序触发的时候，请求七牛云拿到token存为全局变量。123456789101112//app.wpyonLaunch() &#123; //other code *** // 七牛云,获取七牛云token wepy.request(&#123; url: 'https://****************/qiniu_token/', header:&#123;'content-type': 'application/json'&#125;, &#125;).then((res) =&gt; &#123; this.globalData.qiniuToken = res.data.token &#125;);&#125; 导入七牛云文件import qiniuyun from &#39;@/utils/qiniuUploader&#39; base.js代码： 1234567891011121314// 上传图片 base.jsconst uploadImg = (imageURL, uptokenURL) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; qiniuyun.upload(imageURL, (res) =&gt; &#123; resolve(res); &#125;, (error) =&gt; &#123; reject(error); &#125;, &#123; region: 'ECN', domain: '填入域名', uptoken: uptokenURL &#125;); &#125;); &#125; 页面结构 12345678910111213141516&lt;!-- 上传生活照 --&gt; &lt;view class=\"baseInfoTip\" style=\"border: 0\"&gt;上传生活照 &lt;view class=\"imgUploadText\"&gt;(最多9张)&lt;/view&gt; &lt;view class=\"leftOriginLine\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"uploadImgBox\"&gt; &lt;repeat for=\"&#123;&#123;images&#125;&#125;\" index=\"index\" item=\"item\" key=\"index\"&gt; &lt;view class=\"itemBox\"&gt; &lt;image class=\"imgItem\" src=\"&#123;&#123;item&#125;&#125;\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;image class=\"imgItemCancel\" id=\"&#123;&#123;index&#125;&#125;\" src=\"../images/common/icon_cardImg_cancel.png\" @tap.stop=\"cancelUploadImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/repeat&gt; &lt;view class=\"itemBox\" @tap=\"addImg\" wx:if=\"&#123;&#123;!addImgCtrl&#125;&#125;\"&gt; &lt;image class=\"imgItem\" src=\"../images/common/icon_addImg.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; 上传图片业务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 从相册选择照片上传addImg()&#123; const that = this; if( that.buttonClicked === false ) return; that.buttonClicked = false; wepy.chooseImage(&#123; count:9 - that.images.length, sizeType: 'compressed', &#125;).then(async(res1) =&gt; &#123; that.buttonClicked = true; that.toast('上传图片中...','loading'); let filePath = res1.tempFilePaths; for(let i = 0;i &lt; filePath.length;i++)&#123; let imgSrc= res1.tempFilePaths[i]; let imgType = imgSrc.substring(imgSrc.length-3); let imgSize = res1.tempFiles[i].size; if(imgSize &gt; 2000000 || imgType === 'gif')&#123; that.toast('该图片格式错误！请重新选择一张', 'none', 3000); continue &#125; let res = await base.uploadImg(filePath[i], that.$parent.globalData.qiniuToken); that.images.push(res.imageURL); log('image长度：', that.images.length) log('image：', that.images) if( that.images.length &gt;= 9) &#123; that.addImgCtrl = true &#125; if(that.images.length &gt; 9)&#123; that.images = that.images.slice(0,9) &#125; if(that.images.length &gt;0 &amp;&amp; that.config.fImages)&#123; that.config.progress = that.config.progress + parseFloat(that.config.getConfigs.lifepicweight*100); that.config.fImages = false &#125; that.$apply(); // 上传用户头像列表 that.userInfo.photos = that.images if(i === filePath.length -1)&#123; wepy.hideToast(); &#125; &#125; &#125;).catch((res) =&gt; &#123; if(res.errMsg === \"chooseImage:fail:system permission denied\")&#123; that.toast('请打开微信调用摄像头的权限', 'none', 3500) &#125; &#125;)&#125;,// 取消图片上传cancelUploadImg(e) &#123; if( this.images.length &lt; 10 ) &#123; this.addImgCtrl = false &#125; let index = e.target.id this.images.splice(index, 1)&#125;, 微信消息聊天布局 微信聊天框整体布局特点有： 接收方和发送方消息分别位于屏幕的左右两侧、最新的消息一定是在屏幕最底部、进入消息dialog页面一定是显示的最新消息，即页面滑动在最底部。这三个基本特征构成了微信聊天页面的布局原则。 先看效果图 （非最终效果）：↓ 布局思路：flex反向布局 1234567891011121314151617&lt;!-- 格式化代码 --&gt;&lt;view class=\"msgBox\" id=\"msgBox\"&gt; &lt;repeat for=\"&#123;&#123;talkContent&#125;&#125;\" key=\"index\" item=\"item\"&gt; &lt;view class=\"msgItem &#123;&#123;item.send_user === configData.send_user ? 'msgItemReverse' : ''&#125;&#125;\"&gt; &lt;image class=\"adverseHeadimg\" src=\"&#123;&#123;item.send_user === configData.send_user ? configData.user_img : talkAimerInfo.headimg&#125;&#125;\" mode=\"aspectFill\"&gt; &lt;/image&gt; &lt;text class=\"textBox &#123;&#123;item.send_user == configData.send_user ? 'textGreen' : ''&#125;&#125;\" selectable=\"true\"&gt; &#123;&#123;item.message&#125;&#125; &lt;/text&gt; &lt;/view&gt; &lt;view class=\"timeTip\" wx:if=\"&#123;&#123;item.send_user != configData.send_user&#125;&#125;\"&gt; &#123;&#123;item.create_time&#125;&#125; &lt;/view&gt; &lt;/repeat&gt;&lt;/view&gt; 1234.msgBox&#123; display: flex; /*整体消息框flex布局，纵向取反布局*/ flex-direction: column-reverse;&#125; 12345678.msgItem&#123; /*消息item样式*/ position: relative; display: flex; flex-direction: row;&#125;.msgItemReverse&#123; /*对方的消息样式，flex行取反布局*/ flex-direction: row-reverse;&#125; 保持页面始终滑动在最底部函数 12345678910pageScrollToBottom( msgLength ) &#123; //在页面需要进行变化时调用 wx.createSelectorQuery().select('#contentBox').boundingClientRect(function(rect)&#123; // 使页面滚动到底部 log('rect', rect) wx.pageScrollTo(&#123; scrollTop: rect.bottom + msgLength*60, duration: 80 &#125;) log('msgBox的下边界坐标： ', msgLength ) &#125;).exec() &#125; 自己发送的消息数据可以直接压入本地数组 talkContent 内，Unshift()进入，得到“负负得正”效果，即数据反，布局反即可得到从底部排列的布局。对方的消息从服务器拉下来的时候，放入 talkContent 内前 reverse() 一下即可 CSS注意点 CSS持续补充中…… word-break: break-all; //换行文字，英文溢出 -webkit-overflow-scrolling: touch; //ios端启用硬件加速，解决ios端滑动粘手 async/await异步编程的终极解决方案，在小程序内拿取code或者login时会用到，await可理解为求值！async可理解为搭配await的语法，如果异步函数去掉await，返回的一般是 promise 对象，需要手动去reject 和 resolve 。 123456789101112if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;); &#125; else &#123;&#125; ios/android机型区别由于微信小程序的运行规范限制等，一些在 Android 上可以存在的业务需求并不能原封不动在 ios 端运行，否则小心 封号警告 （此处手动滑稽.jpg）,所以一般采取两个系统的用户进入某一个页面，展现不同的内容。判断机型：在 app.wpy 入口文件中，onlaunch 生命周期内判断机型并保存到全局变量即可 12345678getSystemInfo() &#123; const that = this; wx.getSystemInfo(&#123; success(res) &#123; that.globalData.userPlatform = res.platform; &#125; &#125;)&#125; 待更新…….","categories":[],"tags":[]},{"title":"firstBlog","slug":"firstBlog","date":"2019-08-19T07:02:47.000Z","updated":"2019-08-19T07:24:07.104Z","comments":true,"path":"2019/08/19/firstBlog/","link":"","permalink":"http://yoursite.com/2019/08/19/firstBlog/","excerpt":"","text":"#既昨天搞崩GitHub博客，再次坚强的尝试 既昨天搞崩GitHub博客，再次坚强的尝试既昨天搞崩GitHub博客，再次坚强的尝试####既昨天搞崩GitHub博客，再次坚强的尝试 #####既昨天搞崩GitHub博客，再次坚强的尝试 1alert('hello world')","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T03:35:44.767Z","updated":"2019-08-30T09:35:41.625Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}