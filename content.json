{"meta":{"title":"Fanghongliang's blog","subtitle":null,"description":"站在巨人的肩膀上","author":"fanghl","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-19T07:11:42.000Z","updated":"2019-08-19T07:14:52.444Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python与JavaScript对照学习总结点","slug":"learnPython","date":"2019-08-30T08:54:46.460Z","updated":"2019-09-03T06:35:58.059Z","comments":true,"path":"2019/08/30/learnPython/","link":"","permalink":"http://yoursite.com/2019/08/30/learnPython/","excerpt":"","text":"序言Python： 廖雪峰-Python传送门： https://www.liaoxuefeng.com/wiki/1016959663602400命令行打开 .py 文件；Python交互环境，执行Python代码 缩进方式进行代码格式！！4格空格缩进大小写敏感 数据类型： 整数 浮点数 字符串 布尔值 =》 and, or, not 空值 None 列表 字典 变量：1.常量，即不能变的变量，指针指向不变 类const，常量一般为变量名全部大写 除法： / 浮点数除法，即便是两个整数相除，结果也是浮点数 // 地板除，两个整数的除法仍然是整数，结果只取整数 10 // 3 =》 3 % 求模取余 字符串编码： ord() 数获取字符的整数表示 chr() 函数把编码转换为对应的字符Python的字符串类型是str，在内存中以Unicode表示Python对bytes类型的数据用带b前缀的单引号或双引号表示 x = b’abc’ encode() 方法可以编码为指定的bytes decode() 方法 把bytes变为str如果bytes中只有一小部分无效的字节，可以传入errors=’ignore’忽略错误的字节： b’\\xe4\\xb8\\xad\\xff’.decode(‘utf-8’, errors=’ignore’) len() 方法计算str的字符数1个中文字符经过UTF-8编码占用3个字节，而1个英文字符只占用1个字节。 坚持 utf-8 编码 文件开头写上： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 格式化： Python与C一致，都采用 % 实现%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换&#39;age: %s. nmae: %s&#39; %(25, fhl) format() 格式化，比较麻烦 list 和 tuple : list : 列表。类数组 Arrayclassmates = [&#39;xaioming&#39;, &#39;xiaohua&#39;, &#39;xiaoliu&#39;]获取最后一个元素 classmates[len(classmates) - 1] 或者 classmates[-1] list 方法：append(content) 末尾插入insert(index, content) 插入指定位置pop() 删除末尾元素pop(index) 删除指定位置元素 tuple 元组，有序列表一旦初始化，不能更改。没有append、insert方法，其他和list一致因为不能更改，故更为安全，能用tuple代替list就尽量用tuple！t = (1,)t = (&#39;str&#39;, 23, [&#39;a&#39;]) 条件判断: 123456if age &gt;= 18: print('成年人')elif age &gt;= 1: print('幼儿期')else: print('婴儿期') int() 转化为整数函数 循环 for…in循环 while 循环 range() 生成一个整数序列,再通过list()函数可以转换为list break 退出循环 配合if使用 continue 跳过循环 配合if使用 使用dict和set：dictionary字典，其他语言叫map，使用key-value存储，也就是js的对象。json的话，本质是字符串，也可以类比吧。d = {&#39;name&#39;: &#39;fhl&#39;, &#39;age&#39;: 22, }PS: 区别点： js的对象可以使用 . 方法调用，Python目前只能 d[‘age’]或者 d.get(‘age’,-1)获取存储的值删除一个key，可以用 pop(key)dictionary是空间换时间的方法，list时间换空间 set同js中的key同根同源，存储key的集合,不存储value，且key不重复！！！创建set，需要一个list作为输入集合 add(key) 添加元素到set中，重复添加不会有效果 remove(key) 删除元素 set可看做成无序、无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等1234s1 = set([1, 3, 54])s2 = set([2, 3, 4])s1 &amp; s2 # 并 ，单个&amp; s1 | s2 # | 或，单个| 函数自带函数（内置函数）： abs() 、max()数据类型转换函数： int() float() str() bool() 参考js的数据转换函数 String() Number() Boolean() 定义函数：关键字： def, 依次写出函数名、括号、括号中的参数和冒号:,然后，在缩进块中编写函数体，函数的返回值用return语句返回类比js: 关键字function ，后面都一致，然后把 冒号 换成 js中的 大括号 即可 12345def my_abs(num): if x &gt;= 10: return x else: return -x 执行函数： 相比于Python，js的函数执行比较简单，定义完函数后，直接用函数名字加一堆小括号就可以调用当前函数，但Python貌似得先导入该函数，才可以调用 12from test import my_absmy_abs(-1) pass关键字pass语句啥都不做，就和0一样，用来占位的。让程序可以跑起来。可以理解为斗地主时，你的牌大不过上家的，你就可以大吼一声： pass/过，让单线程的斗地主可以走下去，而不至于卡在这里，让队友喷你 Python函数返回值js函数没有return语句时，返回的是 undefined。Python返回的是 None，在存在返回多个值的情况下。Python返回的是tuple，一个tuple可以被好多个变量接收，具体场景参考ES6的解构赋值，一毛一样。 默认参数没啥好讲的，和ES6函数默认参数一毛一样，默认参数在后，必填参数在前 可变参数参数前面添加 * ，在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数，有点意思奥,即便我们的传参是list或者tuple，也可以在参数前加 * ，使得list或者 tuple 变为可变参数传进去 关键字参数**ky可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求 12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 总结： *args是可变参数，args接收的是一个tuple； **kw是关键字参数，kw接收的是一个dict。 递归函数：尾递归优化1234def fact(n): if n==1: return 1 return n * fact(n - 1) 以上代码是Python的递归代码，额，可能耦合性较高，函数内部使用了当前函数的名字，这高度耦合，在js里面我们可以通过 arguments.callee解决调用自身的问题，减小耦合。以下是js代码： 123456function fact(n) &#123; if( n == 1 ) &#123; return 1 &#125; return n * arguments.callee(n-1)&#125; 高级特性：切片 slice操作符slice切片操作符，简单来说，就是给js的slice()函数做了一个语法糖，其他都一致 12L[0:5] #[start:end]但不包括end，L为list或tupleL[-2:-1] #倒数第一个元素索引为-1 所有数，每5个取一个 123456L = list(range(100))L[:10] # 前十个数L[:-10] # 后十个数 L[:10:2] # 前10个数，每两个取一个L[::5] # 所有数，每5个取一个L[:] # 赋值list 切片也可以对字符串使用，不需要单独的类似substring()方法 迭代定义： 循环遍历list或者tuple，叫做迭代。迭代通过 for…in…来完成Python可以迭代一切可迭代的东西判断一个对象是否是可迭代对象呢？ 12from collections import Iterableisinstance('abc', Iterable) # 判断str是否是可迭代的对象，返回Boolean 列表生成式就是简化了复杂列表生成的繁琐步骤 1234567L = [] # 实现一个 1*1, 2*2,....10*10的列表for x in range(1, 11): # 传统方法 L.append( x * x )[x*x for x in range(1, 10)] # 列表生成器[x*x for x in range(1, 10) if x % 2 == 0 ] # 还可以加上 if 判断[m+n for m in 'abc' for n in 'xyz'] # 双层循环 接下来，这行代码可能会让jser稍微羡慕一下，那就是操作文件 12import os # 拿到了当前目录的所有文件夹[d for d in os.listdir('.')] js不能操作文件的，当然表亲 node.js是可以的dict的items() 方法可以同时迭代key和value，那么： 12d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125;[k + '=' + v for k, v in d.items() ] 12d = &#123;'Hello', 'WorLD'&#125; # 把list中所有的字符串小写[s.lower() for s in d] 生成器列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生generator 列表生成式的 [] 改成 () 即可创建生成器12L = [x * x for x in range(10) ] #列表生成式g = (x * x for x in range(10) ) # g是一个generator、next（）方法打印值 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误一般，generator用for来循环，不用next() 12for n in g: print(n) 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' PS::: enerator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中： 1234567g = fib()while True: try: x = next(g) except StopIteration as e: print('Generator return value:', e.value) break 迭代器可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()*判断一个对象是否是 *Iterable 对象 而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用 isinstance() 判断一个对象是否是 Iterator 对象： 1isinstance([], Iterator) 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成 Iterator 可以使用 iter() 函数： 1isinstance(iter([]), Iterator) # True PS: Python的for循环本质上就是通过不断调用next()函数实现的 函数式编程高阶函数函数名是指向函数的变量（同js ），即函数本身可以被变量指着，在变量引用也是可以的一个函数接受另一个函数作为参数，这种函数称为高阶函数（同js） map/reducemap 和 js 的功能一致，即都是为 Iterable 的全部元素应用一种规则。这个规则一般是一个函数。不过语法上稍有不同,js的map是Array的一个方法。 python: map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 12345def f(x): return x*xr = map(f, [1, 2, 3, 4]) # 返回的是list每项的平方list(map(str, [1, 2, 32, 56]) # 把每一项变为字符串 123456789//js实现const arr = [1, 2, 3, 4]const r = arr.map(function(item) &#123; return item*item&#125;)// ES6const r = arr.map(item =&gt; &#123; return iten*item&#125;) 为什么js的map就只是Array的一个方法呢？我个人觉得。js的数据结构并没有Python那么灵活，因为js的for循环只能循环Array和Object，而反观Python就比较多了，本质来说，就是 Iterable 数据结构js只有Array和Object。而Python有很多，除了list和tuple，还有string也算，等等 reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算,其效果就是： 1reduce(f,[x1, x2, x3]) = f(f(f(x1, x2,x3))) #三个f关系？其实这就说明了reduce()这个函数的作用了。 比如说序列求和： 1234from functools import reduce def add(x, y): return x + yreduce(add, [1, 3, 5, 7, 9]) #25 filter()和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 12def is_odd(n): return n % 2 == 1 js中的filter同样是Array的一个方法，用于过滤数组并返回一个新的数组 1234const arr = [5, 16, 35, 15, 48]const r = arr.filter(item =&gt; &#123; //返回r是一个大于18的数组 item &gt;= 18&#125;) 相比于js来说。Python的filter和map类似，都可以作用于Iterable数据类型 sorted()排序内置函数，用法和js的sort()类似。但是js的sort()方法在未传参数的情况下，默认按照字符编码的顺序进行排序。12L = [1, 5, 15, 25, 8]r = sorted(L) #1,5,8,15,25 js的sort(): 12345let arr = [1, 5, 15, 25, 8]arr.sort() // 1,15,25,5,8arr.sort(function(a, b)&#123; //1,5,8,15,25 return a - b&#125;) 看下sorted()的强大：可以传入三个参数，第一就是排序的list，第二个是key的规则，第三个是反转倒叙： 1sorted(['bov','lv','hln', 'Zomp'], key = str.lower, reverse = True) PS : sorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数 返回函数简单看了下返回函数的定义，里面提到了闭包，这个js里面也经常提到的操作。简单说，闭包就是函数嵌套函数，内部的函数保存了外层函数的变量等参数，在外部函数被销毁后，内部函数依旧可以拿到外部函数的传参。这个概念js和Python没大的区别。深层次理解的话，参考另外一篇博客： https://www.cnblogs.com/fanghl/p/11417906.html 匿名函数关键字： lambda只能有一个表达式，不用写return，返回值就是表达式的结果 1234list(map(lambda x: x * x, [1, 3, 5, 7] ))#lambda x: 相当于：def f(x): return x * x python的匿名函数和js的匿名函数不太一样，但作用大都相似，不用担心函数名冲突等等，简化写法等。js里面的匿名函数已经升级到了ES6箭头函数模式，简单方便： 123456item =&gt; &#123; return item * item&#125;(x, y) =&gt; &#123; return x + y&#125; js里面匿名函数用的较少，一般都是用了箭头函数替代了。匿名函数的使用场景我也想不出多少，但在定时器中使用较多： 1234567891011function test() &#123; setTimeout(function() &#123; console.log(1) &#125;, 1000 * 2)&#125;// 不过一般都箭头简化了function test() &#123; setTimeout(() =&gt; &#123; console.log(1) &#125;, 1000 * 2)&#125; 装饰器代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数name 函数对象的该属性可以拿到函数的定义时名字没看懂，等懂了再回来写 偏函数个人理解又是一个语法糖！减少一些函数的繁杂写法关键模块：functools partial 123import functoolsint2 = functolls.partial(int, base = 2)# 创造一个偏函数int2，来进行2进制的转化，base是int内置函数固有的参数 模块模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用创建自己的模块时，要注意：模块名要遵循Python变量命名规范，不要使用中文、特殊字符；模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块 作用域xxx 变量是特殊变量，可以被直接引用，但是有特殊用途_xxx或__xxx这样的函数或者变量是非公开的（private），不应该被直接引用 第三方模块安装 pip：安装第三方模块工具安装命令：pip install xxx 参照 npm 或者 yarn 包管理工具 安装常用模块 在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动安装好了，非常简单易用。Anaconda官网: https://www.anaconda.com/download/国内镜像： https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fpython 面向对象编程 OOP面向过程处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示 12std1 = &#123;'name': 'bob', 'score': 95&#125;std1 = &#123;'name': 'ming', 'score': 59&#125; 处理学生成绩通过函数实现，打印学生成绩： 12def print_score(std): print('%s: %s' % (std['name'], std['score'])) 面向过程，顾名思义，关心的是程序下一步怎么走？这个过程如何保持正确的走法。而面向对象，即万物皆对象，我们要考虑学生这个对象，然后直接创建这个对象，需要什么功能直接调用这个对象上面的方法即可，不用管过程！ 面向对象1234567891011121314class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))xiaoming = Student('xiaoming', 95)xiaohong = Student('xiaohong', 59)xiaoming.print_score()xiaohong.print_score() 奥，语言都是相通的，JavaScript的class和Python思路都是一毛一样啊，不过js中class还有继承、super()、constructor()等等，Python应该也有的，往下继续学习。PS : js中定义的Class，创建实例需要 new 关键字 类和实例 创建类class + className + (继承自某个类) 12class Students(object): def __init__(self, xxx, xx1, xx2): 1234567891011121314class Student extends Person&#123; //js实现 super() //继承基类的属性 constructor(name, age) &#123; //自己的属性 this.speed = 30 this.name = name this.age = age &#125; otherMethods() &#123; //挂载到Student的原型链上 doSth... &#125;, otherMethods1() &#123; //挂载到Student的原型链上 doOther... &#125;&#125; 创建实例12# pyxiaoming = Student(arg) 12// jsconst xioaming = new Student(arg) 看到这，终于深刻体会到了为啥class一定要首字母大写！js里面可能体会不深，因为有 new 关键字在class之前，而py里面，如果不区分，那么很容易搞混class 和 function 特殊方法init 方法的第一个参数永远是self，表示创建的实例本身，因此，在init方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。diff:和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。 访问限制外部代码还是可以自由地修改一个实例的name、score属性： 12xiaoming = Student('xiaoming', 95)xioaming.score = 12 #可以修改实例的属性 大招来了！！！如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__这个大招js里面可没有啊在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问 1234class Student(object): __init__(self, name, age): self.__name = name self__age = age 这样在外部就无法访问到内部的私有变量了，只能调用内部方法来访问。·····~真的是这样的吗？（手动滑稽.jpg）,当然不是啦，之所有我们无法从外部访问到name,是因为Python解释器把该变量变成了 _Studentname ,所以呢，我们可以通过 短线 加 类名 加变量名继续来访问该私有变量吃饱了撑着了吗？哈哈 继承和多态有点C++的感觉了，毕竟js是没有显示的多态的~ 等等，我理解完了，凉凉打脸。Python的多态指的是基类和子类拥有同样的方法时，子类覆盖基类………………尼玛，按照js来说，这就是原型链的查找基本原理啊，先在自己内部找，找不到了就顺着原型链往上查找，一毛一样的……….把py中的class理解为一种数据结构，这个数据结构和py自带的list,tuple,dict 没有任何区别。那么 isinstance() 不就可以用了 12345678xiaoming = Student('xiaoming')isinstance(xiaoming, Student) # True isinstance可以理解为派生class Pupil(Student): passxiaoxioa = Pupil()isinstance(xiaoxiao, Student) # True 隔代的也算派生哦 鸭子模型 动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。 获取对象信息 type()判断对象类型，js中使用 typeof() , js判断字符串还可以更为准确的使用Object.prototype.toString().call()题外话了，js的type判断基本类型好用，其他就还是用 instanceof（）这点上，JS和py还是高度相似的！！type() ===== typeof() ===== 基本类型isinstance() ==== instanceof() ===== 判断对象 dir()要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态, js中同理。setAttribute()、getAttribute()、hasAttribute() 实例属性和类属性总结一句话，就是class的类属性各个实例都会访问到，实例的实例属性各自相互独立。可以把这两个概念理解为 JS 基类中的方法，子类都会顺着原型链找到并访问到。 12class Student(object): school = 'hantaiMiddleSchool' #所有实例都可以访问到 面向对象高级编程slotsslots的作用就是动态给class添加属性的一个约束，否则在class类建立完毕后，运行代码的时候动态随意绑定属性不就乱套了，需要一个约束，职责就是 slotsslots 英文： 插槽。在Vue中使用的广泛，可以理解为在这预先给你留了个位置，以后想用的时候可以用，没有留这个位置的话，以后相用都用不了，可以理解为图书馆同学帮你占座 1234567#pythonclass Student(object): __slots__ = ('name', 'age')&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'xiaoming' # 可以绑定成功&gt;&gt;&gt; s.score = 98 # 会报错，“唉，这位置有人了，你坐不了（手动滑稽.jpg）” PS : 使用slots要注意，slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用 @property解决问题前言：给Class绑定属性时，直接把属性暴露出去，写起来简单，调用起来简单，但是没办法检查参数，导致可以随便修改值。这不合理解决1： 123456789101112131415#Python#Python设置set、get方法来控制属性解决验证问题class Student(onject): def get_score(self): return self.score def set_scsoe(self, value): if not isinstance(value, int): raise ValueError('score must be int') if value &lt; 0 or value &gt; 100: raise ValueError('score must be 0-100') self.score = value 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：总结起来：语法糖，本质没变，但是简化了调用的繁琐程度 12345678910111213141516171819class Student(object): @property def score(self): return self.score @score.setter # 可读可写属性 def score(self, valule): if not isinstance(value, int): raise ValueError('score must be int') if value &lt; 0 or value &gt; 100: raise ValueError('score must be 0-100') self.score = value @property #只读属性 def age(self): return 23#这样，就依旧可以使用属性的.调用方法访问属性、设置属性值了 总结：@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性 多重继承关键字：一个子类可以拥有多个基类、mixinclass需要新的功能，只需要在继承一个基类就可以了，通常，主线都是单一继承下来的 * 为了更好地看出继承关系，我们把主线之外需要继承的基类命名为 Mixin，这样的的设计通常称为 *Mixin 12345678class Person(object): passclass ChineseMixin(Person): passclass ChinaPuple(Person, ChineseMixin): pass 定制类重点：前后双下划线的变量是特殊变量，py有特殊用途的！！slotslen()strrepritergetitemsetitemgetattrcall上面罗列的方法未查看相关作用，以后需要用到在查看不迟，就最后一个 call ,在js 中调用自身的有 arguments.callee() 枚举类…持续更新…….","categories":[],"tags":[]},{"title":"七月份项目自我总结","slug":"summary201907","date":"2019-08-27T07:58:55.819Z","updated":"2019-08-30T09:49:11.320Z","comments":true,"path":"2019/08/27/summary201907/","link":"","permalink":"http://yoursite.com/2019/08/27/summary201907/","excerpt":"","text":"七月份项目自我总结小程序： 相亲小红圈+tool： wepy 传送门：[ wepy ] https://tencent.github.io/wepy/document.html#/[ Vue ] https://cn.vuejs.org/[ ES6 ] http://es6.ruanyifeng.com/[ git ] https://www.liaoxuefeng.com/ 七月份结束，项目上线，回过头来整理一下项目，项目为wepy1.7.0后版本开发的小程序，配套的后台前端使用ant-design-vue开发，上传测试服工具使用Xshell6。简介 wepy构建工程 目录 定时器 组件传值 三层组件，点击事件传播 token验证 formID 支付 图片上传 微信消息聊天布局 CSS注意点 async/await ios/android机型区别 content简介 wepy构建工程具体可在wepy官网中查看，此处不多介绍。 1234$ wepy init standard my-project /**创建项目*/$ cd my-project /*进入项目目录*/$ npm install /**安装依赖*/$ wepy build --watch /*运行工程并监控项目修改自动刷新*/ 1wepy属于类Vue写法，要在wepy中使用异步操作（async/await）需要在工程的app.way入口文件中constructor函数中注册: 12345constructor () &#123; super() this.use('requestfix') this.use('promisify') /*←手动添加这个*/&#125; 版本更新代码，一般较为固定，直接复制在 onLaunch 生命周期内 123456789101112131415161718192021222324if(wx.canIUse('getUpdateManager'))&#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; if(res.hasUpdate)&#123; updateManager.onUpdateReady((res) =&gt; &#123; wx.showModal(&#123; title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) &#123; if(res.confirm)&#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: '已经有新版本了哟~', content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~' &#125;) &#125;) &#125; &#125;)&#125; content目录 定时器页面业务逻辑有需要用到倒计时功能，如下图。 在页面中有需要用到倒计时或者其他定时器任务时，新建的定时器在卸载页面时一定要清除掉，有时候页面可能不止一个定时器需求，在卸载页面（onUnload钩子函数）的时候一定要清除掉当前不用的定时器定时器用来做倒计时效果也不错，初始时间后台获取，前端处理，后台直接在数据库查询拿到的标准时间（数据库原始时间，T分割），前端需要正则处理一下这个时间： 123456let overTimeStr = data.over_time.split('T')let time1 = overTimeStr[0].replace(/-/g,\",\")let time2 = overTimeStr[1].replace(/:/g,',')let overTime = time1+ ',' + time2let overTimeArr = overTime.split(',')this.countDownCtrl( overTimeArr, 0 ); 最终把时间分割为[年，月， 日， 时， 分， 秒]的数组，（如果后端已经把时间处理过了那就更好了），然后把该数组传递给倒计时函数 123456789101112131415161718192021222324252627282930313233countDownCtrl( time, group ) &#123; let deadline = new Date()//免费截止时间，月的下从0开始 deadline.setFullYear(time[0], time[1]-1, time[2]) deadline.setHours(time[3], time[4], time[5]) let curTimeJudge = new Date().getTime() let timeJudge = deadline.getTime()-curTimeJudge let remainTimeJudge = parseInt(timeJudge/1000) if( remainTimeJudge &lt; 0) &#123; log('倒计时已经过期') return; &#125; this.interva1 = setInterval(() =&gt; &#123; let curTime = new Date().getTime() let time = deadline.getTime()-curTime //剩余毫秒数 let remainTime = parseInt(time/1000) //总的剩余时间,以秒计 let day = parseInt( remainTime/(24*3600) )//剩余天 let hour = parseInt( (remainTime-day*24*3600)/3600 )//剩余小时 let minute = parseInt((remainTime-day*24*3600-hour*3600)/60)//剩余分钟 let sec = parseInt(remainTime%60)//剩余秒 hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute : minute sec = sec &lt; 10 ? '0' + sec : sec let countDownText = hour+ \":\" +minute+ \":\" +sec if( group === 0) &#123; //个人业务逻辑，因为一个页面有两个倒计时需求，代码复用区分 this.countDown = countDownText; &#125; else if( group === 1 ) &#123; this.countDownGroup = countDownText &#125; this.$apply() &#125;, 1000 ); &#125; 至此，倒计时效果处理完毕，PS：终止时间一定要大于currentDate，否则显示会出现异常（包括但不限于倒计时闪烁、乱码等） 最后，退出该页面去其他页面时，一定要在页码卸载钩子中清除倒计时！！！ 123onUnload() &#123; clearInterval(this.interva1);&#125; 组件传值组件传值和Vue有点细微区别，Vue强调父组件的数组和对象不要直接传到子组件使用，应为子组件可能会修改这个data，如图： 但是，wepy中，有时候确实需要把一个对象传递到子组件使用，单个传递对象属性过于繁琐，而且！！！如果单个传递对象的属性到子组件，如果该属性是一个数组，则子组件永远会接收到 undefined 。此时最好用整个对象传值替代单个对象属性逐个传值的方法，且一定要在传值时加入 .sync 修饰符，双向传值绑定。确保从接口拿到的数据也能实时传递到子组件，而非 undefined :circleMembersList.sync=&quot;circleMembersList&quot; 阻止组件的点击事件传播 解决： 添加函数 catchtap=”funcName” 即可，funcName可为空函数，也可以直接不写 token判断小程序调试时，有时候会出现首次打开无内容（拿不到数据）的状态，需要“杀死”小程序再打开才能看到数据内容，其中可能的原因之一便是 token 的失效。在与后台交互的时候，token必不可少。尤其是在小程序分享出去的链接，由其他用户点开分享链接进入小程序内部，此时更是要判断token，token的判断一般选在 onShow（）钩子执行而不在 onLoad（）钩子内执行。若不存在token，则应该执行登录去拿取token，再进行业务逻辑 1234567891011onShow() &#123; const that = this; if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) &#125; &#125;); &#125; &#125; formid微信提供了服务通知，即在你支付、快递等行为时，微信会直接给你发一个服务通知（模板消息）来提醒，每次提醒都会消耗该用户存储的formID，formID为消耗品，用一个少一个，只有通过用户的表单提交行为才可以积攒formID 12345678&lt;form @submit=\"submitForm\" report-submit=\"true\"&gt; &lt;button form-type=\"submit\" class=\"editCard\" @tap = \"goModifiPage('editFormTab')\"&gt;修改&lt;/button&gt;&lt;/form&gt;//js方法submitForm(e) &#123; this.postFormId( e.detail.formId ) // 向后端传输formid&#125; 支付准备： crypto-js.js &amp;&amp; md5.js微信支付流程为： 前端点击支付按钮拉起支付 ==》 准备加密数据 ==》 调用后端接口，传入需要的加密数据 ==》 后端验证加密数据，再返回加密数据 ==》 前端拿到后端加密数据（时间戳、内容、签名），对时间戳和内容进行本地签名，再判断本地签名和后端签名是否一致，若不一致，直接返回，退出支付，支付失败！若一致，对刚刚后台返回的content（内容）进行解析，拿到所需订单数据，前端拉起微信支付，参数传入刚刚解析数据 ===》 得到支付结果 success or fail ！结束 12345678/** * 签名函数 Sign */function sign(timestamp, content) &#123; var raw = timestamp + salt + content var hash = CryptoJS.SHA256(raw).toString() return CryptoJS.MD5(hash).toString()&#125; 前端点击支付按钮： 123456789101112131415161718192021222324252627// 单独支付接口alonePay(arg) &#123; const that = this; if( that.buttonClicked === false ) return; //防止重复多次拉起支付 that.buttonClicked = false; let mode = 1; //业务需求，我有五种不同模式支付 let appId = this.$parent.globalData.appId; let content; let sign; const timeStamp = new Date().Format(\"yyyy-MM-dd hh:mm:ss\").toString(); let code = wepy.getStorageSync('code'); wepy.login().then((res) =&gt; &#123; //获取最新的code，可能这里没必要，具体和后端商量 if(res.code) &#123; let code = res.code; log('code', code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;).then( res =&gt; &#123; content = `mode=$&#123;mode&#125;&amp;app_id=$&#123;appId&#125;` sign = Sign.sign(timeStamp,content); &#125;).then(res =&gt; &#123; that.goCirclePay( that.circle_id, timeStamp, sign, content, mode ) &#125;)&#125;, 支付函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 支付函数，我前端有五种支付情况（单独、自己发起拼团、拼别人团、ios、免费五种支付），所以单独抽出支付，每次调用支付函数goCirclePay( circle_id, timestamp, sign, content, mode) &#123; const that = this; circleApi.goCirclePay(&#123; data: &#123; circle_id, timestamp, sign, content &#125;, getToken: true &#125;).then( res =&gt; &#123; log('支付res：', res) let data = res.data const SignServer = data.sign const timeStampServer = data.timestamp let contentServer = data.content const SignLocal = Sign.sign(timeStampServer,contentServer); if( mode === 0 &amp;&amp; data.status === \"success\") &#123; that.nav('/pages/circleDetail?circle_id=' + that.circle_id) return; &#125; if( SignLocal !== SignServer ) &#123; log('签名不一致！') wx.showToast(&#123; title: \"您已经支付过了\", duration: 1500, image: \"../images/common/icon_wxchat.png\", &#125;) return &#125; let contentArr = contentServer.split('&amp;') const timeStamp = contentArr[0].split('=')[1]; const nonceStr = contentArr[1].split('=')[1]; let index = contentArr[2].indexOf(\"=\"); const package1 = contentArr[2].slice(index+1) const signType = contentArr[3].split('=')[1]; const paySign = contentArr[4].split('=')[1]; wepy.requestPayment(&#123; timeStamp, nonceStr, package: package1, signType, paySign &#125;).then(res =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;) &#125;).then(res =&gt; &#123; //支付后promise，这里有成功和fail两种，fail在catch捕获，这里直接开始写支付success后的业务代码 that.buttonClicked = true; let groupFormIdGet; circleApi.getGroupFormId(&#123; ////获取getGroupFormId data: &#123; circle_id: that.circle_id &#125;, getToken: true &#125;).then( res =&gt; &#123; // let data = res.data that.group_form_id = data.group_form_id groupFormIdGet = data.group_form_id if( mode === 1) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;shareLink=$&#123;that.shareLink&#125;`) &#125; else if( mode === 2) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;group_form_id=$&#123;groupFormIdGet&#125;`) &#125; that.$apply() //脏值检查触发 &#125;) &#125;).catch(res =&gt; &#123; log('支付失败', res) that.buttonClicked = true; &#125;) &#125;)&#125; 图片上传（七牛云）更多图床网站请见我博客： https://www.cnblogs.com/fanghl/p/11419914.html图片上传服务器采用七牛云服务，在app.wpy内小程序触发的时候，请求七牛云拿到token存为全局变量。123456789101112//app.wpyonLaunch() &#123; //other code *** // 七牛云,获取七牛云token wepy.request(&#123; url: 'https://****************/qiniu_token/', header:&#123;'content-type': 'application/json'&#125;, &#125;).then((res) =&gt; &#123; this.globalData.qiniuToken = res.data.token &#125;);&#125; 导入七牛云文件import qiniuyun from &#39;@/utils/qiniuUploader&#39; base.js代码： 1234567891011121314// 上传图片 base.jsconst uploadImg = (imageURL, uptokenURL) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; qiniuyun.upload(imageURL, (res) =&gt; &#123; resolve(res); &#125;, (error) =&gt; &#123; reject(error); &#125;, &#123; region: 'ECN', domain: '填入域名', uptoken: uptokenURL &#125;); &#125;); &#125; 页面结构 12345678910111213141516&lt;!-- 上传生活照 --&gt; &lt;view class=\"baseInfoTip\" style=\"border: 0\"&gt;上传生活照 &lt;view class=\"imgUploadText\"&gt;(最多9张)&lt;/view&gt; &lt;view class=\"leftOriginLine\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"uploadImgBox\"&gt; &lt;repeat for=\"&#123;&#123;images&#125;&#125;\" index=\"index\" item=\"item\" key=\"index\"&gt; &lt;view class=\"itemBox\"&gt; &lt;image class=\"imgItem\" src=\"&#123;&#123;item&#125;&#125;\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;image class=\"imgItemCancel\" id=\"&#123;&#123;index&#125;&#125;\" src=\"../images/common/icon_cardImg_cancel.png\" @tap.stop=\"cancelUploadImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/repeat&gt; &lt;view class=\"itemBox\" @tap=\"addImg\" wx:if=\"&#123;&#123;!addImgCtrl&#125;&#125;\"&gt; &lt;image class=\"imgItem\" src=\"../images/common/icon_addImg.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; 上传图片业务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 从相册选择照片上传addImg()&#123; const that = this; if( that.buttonClicked === false ) return; that.buttonClicked = false; wepy.chooseImage(&#123; count:9 - that.images.length, sizeType: 'compressed', &#125;).then(async(res1) =&gt; &#123; that.buttonClicked = true; that.toast('上传图片中...','loading'); let filePath = res1.tempFilePaths; for(let i = 0;i &lt; filePath.length;i++)&#123; let imgSrc= res1.tempFilePaths[i]; let imgType = imgSrc.substring(imgSrc.length-3); let imgSize = res1.tempFiles[i].size; if(imgSize &gt; 2000000 || imgType === 'gif')&#123; that.toast('该图片格式错误！请重新选择一张', 'none', 3000); continue &#125; let res = await base.uploadImg(filePath[i], that.$parent.globalData.qiniuToken); that.images.push(res.imageURL); log('image长度：', that.images.length) log('image：', that.images) if( that.images.length &gt;= 9) &#123; that.addImgCtrl = true &#125; if(that.images.length &gt; 9)&#123; that.images = that.images.slice(0,9) &#125; if(that.images.length &gt;0 &amp;&amp; that.config.fImages)&#123; that.config.progress = that.config.progress + parseFloat(that.config.getConfigs.lifepicweight*100); that.config.fImages = false &#125; that.$apply(); // 上传用户头像列表 that.userInfo.photos = that.images if(i === filePath.length -1)&#123; wepy.hideToast(); &#125; &#125; &#125;).catch((res) =&gt; &#123; if(res.errMsg === \"chooseImage:fail:system permission denied\")&#123; that.toast('请打开微信调用摄像头的权限', 'none', 3500) &#125; &#125;)&#125;,// 取消图片上传cancelUploadImg(e) &#123; if( this.images.length &lt; 10 ) &#123; this.addImgCtrl = false &#125; let index = e.target.id this.images.splice(index, 1)&#125;, 微信消息聊天布局 微信聊天框整体布局特点有： 接收方和发送方消息分别位于屏幕的左右两侧、最新的消息一定是在屏幕最底部、进入消息dialog页面一定是显示的最新消息，即页面滑动在最底部。这三个基本特征构成了微信聊天页面的布局原则。 先看效果图 （非最终效果）：↓ 布局思路：flex反向布局 1234567891011121314151617&lt;!-- 格式化代码 --&gt;&lt;view class=\"msgBox\" id=\"msgBox\"&gt; &lt;repeat for=\"&#123;&#123;talkContent&#125;&#125;\" key=\"index\" item=\"item\"&gt; &lt;view class=\"msgItem &#123;&#123;item.send_user === configData.send_user ? 'msgItemReverse' : ''&#125;&#125;\"&gt; &lt;image class=\"adverseHeadimg\" src=\"&#123;&#123;item.send_user === configData.send_user ? configData.user_img : talkAimerInfo.headimg&#125;&#125;\" mode=\"aspectFill\"&gt; &lt;/image&gt; &lt;text class=\"textBox &#123;&#123;item.send_user == configData.send_user ? 'textGreen' : ''&#125;&#125;\" selectable=\"true\"&gt; &#123;&#123;item.message&#125;&#125; &lt;/text&gt; &lt;/view&gt; &lt;view class=\"timeTip\" wx:if=\"&#123;&#123;item.send_user != configData.send_user&#125;&#125;\"&gt; &#123;&#123;item.create_time&#125;&#125; &lt;/view&gt; &lt;/repeat&gt;&lt;/view&gt; 1234.msgBox&#123; display: flex; /*整体消息框flex布局，纵向取反布局*/ flex-direction: column-reverse;&#125; 12345678.msgItem&#123; /*消息item样式*/ position: relative; display: flex; flex-direction: row;&#125;.msgItemReverse&#123; /*对方的消息样式，flex行取反布局*/ flex-direction: row-reverse;&#125; 保持页面始终滑动在最底部函数 12345678910pageScrollToBottom( msgLength ) &#123; //在页面需要进行变化时调用 wx.createSelectorQuery().select('#contentBox').boundingClientRect(function(rect)&#123; // 使页面滚动到底部 log('rect', rect) wx.pageScrollTo(&#123; scrollTop: rect.bottom + msgLength*60, duration: 80 &#125;) log('msgBox的下边界坐标： ', msgLength ) &#125;).exec() &#125; 自己发送的消息数据可以直接压入本地数组 talkContent 内，Unshift()进入，得到“负负得正”效果，即数据反，布局反即可得到从底部排列的布局。对方的消息从服务器拉下来的时候，放入 talkContent 内前 reverse() 一下即可 CSS注意点 CSS持续补充中…… word-break: break-all; //换行文字，英文溢出 -webkit-overflow-scrolling: touch; //ios端启用硬件加速，解决ios端滑动粘手 async/await异步编程的终极解决方案，在小程序内拿取code或者login时会用到，await可理解为求值！async可理解为搭配await的语法，如果异步函数去掉await，返回的一般是 promise 对象，需要手动去reject 和 resolve 。 123456789101112if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;); &#125; else &#123;&#125; ios/android机型区别由于微信小程序的运行规范限制等，一些在 Android 上可以存在的业务需求并不能原封不动在 ios 端运行，否则小心 封号警告 （此处手动滑稽.jpg）,所以一般采取两个系统的用户进入某一个页面，展现不同的内容。判断机型：在 app.wpy 入口文件中，onlaunch 生命周期内判断机型并保存到全局变量即可 12345678getSystemInfo() &#123; const that = this; wx.getSystemInfo(&#123; success(res) &#123; that.globalData.userPlatform = res.platform; &#125; &#125;)&#125; 待更新…….","categories":[],"tags":[]},{"title":"firstBlog","slug":"firstBlog","date":"2019-08-19T07:02:47.000Z","updated":"2019-08-19T07:24:07.104Z","comments":true,"path":"2019/08/19/firstBlog/","link":"","permalink":"http://yoursite.com/2019/08/19/firstBlog/","excerpt":"","text":"#既昨天搞崩GitHub博客，再次坚强的尝试 既昨天搞崩GitHub博客，再次坚强的尝试既昨天搞崩GitHub博客，再次坚强的尝试####既昨天搞崩GitHub博客，再次坚强的尝试 #####既昨天搞崩GitHub博客，再次坚强的尝试 1alert('hello world')","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T03:35:44.767Z","updated":"2019-08-30T09:35:41.625Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}