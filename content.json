{"meta":{"title":"Fanghongliang's blog","subtitle":null,"description":"站在巨人的肩膀上","author":"fanghl","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-19T07:11:42.000Z","updated":"2019-08-19T07:14:52.444Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"summary201907","date":"2019-08-27T07:58:55.819Z","updated":"2019-08-27T12:44:55.283Z","comments":true,"path":"2019/08/27/summary201907/","link":"","permalink":"http://yoursite.com/2019/08/27/summary201907/","excerpt":"","text":"七月份项目自我总结小程序： 相亲小红圈+tool： wepy 传送门：[ wepy ] https://tencent.github.io/wepy/document.html#/[ Vue ] https://cn.vuejs.org/[ ES6 ] http://es6.ruanyifeng.com/[ git ] https://www.liaoxuefeng.com/ 七月份结束，项目上线，回过头来整理一下项目，项目为wepy1.7.0后版本开发的小程序，配套的后台前端使用ant-design-vue开发，上传测试服工具使用Xshell6。简介 wepy构建工程 目录 定时器 组件传值 三层组件，点击事件传播 token验证 formID 支付 图片上传 微信消息聊天布局 CSS注意点 async/await ios/android机型区别 content简介 wepy构建工程具体可在wepy官网中查看，此处不多介绍。 123456789101112$ wepy init standard my-project /**创建项目*/$ cd my-project /*进入项目目录*/$ npm install /**安装依赖*/$ wepy build --watch /*运行工程并监控项目修改自动刷新*/``` wepy属于类Vue写法，要在wepy中使用异步操作（async/await）需要在工程的app.way入口文件中constructor函数中注册： ```javascriptconstructor () &#123; super() this.use(&apos;requestfix&apos;) this.use(&apos;promisify&apos;) /*←手动添加这个*/&#125; 版本更新代码，一般较为固定，直接复制在 onLaunch 生命周期内 12345678910111213141516171819202122232425// 提示版本更新 if(wx.canIUse('getUpdateManager'))&#123; const updateManager = wx.getUpdateManager(); updateManager.onCheckForUpdate((res) =&gt; &#123; if(res.hasUpdate)&#123; updateManager.onUpdateReady((res) =&gt; &#123; wx.showModal(&#123; title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) &#123; if(res.confirm)&#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: '已经有新版本了哟~', content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~' &#125;) &#125;) &#125; &#125;) &#125; content目录 定时器页面业务逻辑有需要用到倒计时功能，如下图。 在页面中有需要用到倒计时或者其他定时器任务时，新建的定时器在卸载页面时一定要清除掉，有时候页面可能不止一个定时器需求，在卸载页面（onUnload钩子函数）的时候一定要清除掉当前不用的定时器定时器用来做倒计时效果也不错，初始时间后台获取，前端处理，后台直接在数据库查询拿到的标准时间（数据库原始时间，T分割），前端需要正则处理一下这个时间： 123456let overTimeStr = data.over_time.split('T')let time1 = overTimeStr[0].replace(/-/g,\",\")let time2 = overTimeStr[1].replace(/:/g,',')let overTime = time1+ ',' + time2let overTimeArr = overTime.split(',')this.countDownCtrl( overTimeArr, 0 ); 最终把时间分割为[年，月， 日， 时， 分， 秒]的数组，（如果后端已经把时间处理过了那就更好了），然后把该数组传递给倒计时函数 123456789101112131415161718192021222324252627282930313233countDownCtrl( time, group ) &#123; let deadline = new Date()//免费截止时间，月的下从0开始 deadline.setFullYear(time[0], time[1]-1, time[2]) deadline.setHours(time[3], time[4], time[5]) let curTimeJudge = new Date().getTime() let timeJudge = deadline.getTime()-curTimeJudge let remainTimeJudge = parseInt(timeJudge/1000) if( remainTimeJudge &lt; 0) &#123; log('倒计时已经过期') return; &#125; this.interva1 = setInterval(() =&gt; &#123; let curTime = new Date().getTime() let time = deadline.getTime()-curTime //剩余毫秒数 let remainTime = parseInt(time/1000) //总的剩余时间,以秒计 let day = parseInt( remainTime/(24*3600) )//剩余天 let hour = parseInt( (remainTime-day*24*3600)/3600 )//剩余小时 let minute = parseInt((remainTime-day*24*3600-hour*3600)/60)//剩余分钟 let sec = parseInt(remainTime%60)//剩余秒 hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute : minute sec = sec &lt; 10 ? '0' + sec : sec let countDownText = hour+ \":\" +minute+ \":\" +sec if( group === 0) &#123; //个人业务逻辑，因为一个页面有两个倒计时需求，代码复用区分 this.countDown = countDownText; &#125; else if( group === 1 ) &#123; this.countDownGroup = countDownText &#125; this.$apply() &#125;, 1000 ); &#125; 至此，倒计时效果处理完毕，PS：终止时间一定要大于currentDate，否则显示会出现异常（包括但不限于倒计时闪烁、乱码等） 最后，退出该页面去其他页面时，一定要在页码卸载钩子中清除倒计时！！！ 123onUnload() &#123; clearInterval(this.interva1);&#125; 组件传值组件传值和Vue有点细微区别，Vue强调父组件的数组和对象不要直接传到子组件使用，应为子组件可能会修改这个data，如图： 但是，wepy中，有时候确实需要把一个对象传递到子组件使用，单个传递对象属性过于繁琐，而且！！！如果单个传递对象的属性到子组件，如果该属性是一个数组，则子组件永远会接收到 undefined 。此时最好用整个对象传值替代单个对象属性逐个传值的方法，且一定要在传值时加入 .sync 修饰符，双向传值绑定。确保从接口拿到的数据也能实时传递到子组件，而非 undefined :circleMembersList.sync=&quot;circleMembersList&quot; 阻止组件的点击事件传播 解决： 添加函数 catchtap=”funcName” 即可，funcName可为空函数，也可以直接不写 token判断小程序调试时，有时候会出现首次打开无内容（拿不到数据）的状态，需要“杀死”小程序再打开才能看到数据内容，其中可能的原因之一便是 token 的失效。在与后台交互的时候，token必不可少。尤其是在小程序分享出去的链接，由其他用户点开分享链接进入小程序内部，此时更是要判断token，token的判断一般选在 onShow（）钩子执行而不在 onLoad（）钩子内执行。若不存在token，则应该执行登录去拿取token，再进行业务逻辑 1234567891011onShow() &#123; const that = this; if( !wepy.getStorageSync('token') ) &#123; wepy.login().then(async (res) =&gt; &#123; if(res.code) &#123; let code = res.code; await that.login(code) &#125; &#125;); &#125; &#125; formid微信提供了服务通知，即在你支付、快递等行为时，微信会直接给你发一个服务通知（模板消息）来提醒，每次提醒都会消耗该用户存储的formID，formID为消耗品，用一个少一个，只有通过用户的表单提交行为才可以积攒formID 12345678&lt;form @submit=\"submitForm\" report-submit=\"true\"&gt; &lt;button form-type=\"submit\" class=\"editCard\" @tap = \"goModifiPage('editFormTab')\"&gt;修改&lt;/button&gt;&lt;/form&gt;//js方法submitForm(e) &#123; this.postFormId( e.detail.formId ) // 向后端传输formid&#125; 支付准备： crypto-js.js &amp;&amp; md5.js微信支付流程为： 前端点击支付按钮拉起支付 ==》 准备加密数据 ==》 调用后端接口，传入需要的加密数据 ==》 后端验证加密数据，再返回加密数据 ==》 前端拿到后端加密数据（时间戳、内容、签名），对时间戳和内容进行本地签名，再判断本地签名和后端签名是否一致，若不一致，直接返回，退出支付，支付失败！若一致，对刚刚后台返回的content（内容）进行解析，拿到所需订单数据，前端拉起微信支付，参数传入刚刚解析数据 ===》 得到支付结果 success or fail ！结束 12345678/** * 签名函数 Sign */function sign(timestamp, content) &#123; var raw = timestamp + salt + content var hash = CryptoJS.SHA256(raw).toString() return CryptoJS.MD5(hash).toString()&#125; 前端点击支付按钮： 123456789101112131415161718192021222324252627// 单独支付接口alonePay(arg) &#123; const that = this; if( that.buttonClicked === false ) return; //防止重复多次拉起支付 that.buttonClicked = false; let mode = 1; //业务需求，我有五种不同模式支付 let appId = this.$parent.globalData.appId; let content; let sign; const timeStamp = new Date().Format(\"yyyy-MM-dd hh:mm:ss\").toString(); let code = wepy.getStorageSync('code'); wepy.login().then((res) =&gt; &#123; //获取最新的code，可能这里没必要，具体和后端商量 if(res.code) &#123; let code = res.code; log('code', code) wepy.setStorage(&#123; key: \"code\", data: code &#125;) &#125; &#125;).then( res =&gt; &#123; content = `mode=$&#123;mode&#125;&amp;app_id=$&#123;appId&#125;` sign = Sign.sign(timeStamp,content); &#125;).then(res =&gt; &#123; that.goCirclePay( that.circle_id, timeStamp, sign, content, mode ) &#125;)&#125;, 支付函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 支付函数，我前端有五种支付情况（单独、自己发起拼团、拼别人团、ios、免费五种支付），所以单独抽出支付，每次调用支付函数goCirclePay( circle_id, timestamp, sign, content, mode) &#123; const that = this; circleApi.goCirclePay(&#123; data: &#123; circle_id, timestamp, sign, content &#125;, getToken: true &#125;).then( res =&gt; &#123; log('支付res：', res) let data = res.data const SignServer = data.sign const timeStampServer = data.timestamp let contentServer = data.content const SignLocal = Sign.sign(timeStampServer,contentServer); if( mode === 0 &amp;&amp; data.status === \"success\") &#123; that.nav('/pages/circleDetail?circle_id=' + that.circle_id) return; &#125; if( SignLocal !== SignServer ) &#123; log('签名不一致！') wx.showToast(&#123; title: \"您已经支付过了\", duration: 1500, image: \"../images/common/icon_wxchat.png\", &#125;) return &#125; let contentArr = contentServer.split('&amp;') const timeStamp = contentArr[0].split('=')[1]; const nonceStr = contentArr[1].split('=')[1]; let index = contentArr[2].indexOf(\"=\"); const package1 = contentArr[2].slice(index+1) const signType = contentArr[3].split('=')[1]; const paySign = contentArr[4].split('=')[1]; wepy.requestPayment(&#123; timeStamp, nonceStr, package: package1, signType, paySign &#125;).then(res =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;) &#125;).then(res =&gt; &#123; //支付后promise，这里有成功和fail两种，fail在catch捕获，这里直接开始写支付success后的业务代码 that.buttonClicked = true; let groupFormIdGet; circleApi.getGroupFormId(&#123; ////获取getGroupFormId data: &#123; circle_id: that.circle_id &#125;, getToken: true &#125;).then( res =&gt; &#123; // let data = res.data that.group_form_id = data.group_form_id groupFormIdGet = data.group_form_id if( mode === 1) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;shareLink=$&#123;that.shareLink&#125;`) &#125; else if( mode === 2) &#123; that.nav(`/pages/paySuccess?circle_id=$&#123;that.circle_id&#125;&amp;group_form_id=$&#123;groupFormIdGet&#125;`) &#125; that.$apply() //脏值检查触发 &#125;) &#125;).catch(res =&gt; &#123; log('支付失败', res) that.buttonClicked = true; &#125;) &#125;)&#125; 图片上传（七牛云）更多图床网站请见我博客： https://www.cnblogs.com/fanghl/p/11419914.html图片上传服务器采用七牛云服务，在app.wpy内小程序触发的时候，请求七牛云拿到token存为全局变量。123456789101112//app.wpyonLaunch() &#123; //other code *** // 七牛云,获取七牛云token wepy.request(&#123; url: 'https://****************/qiniu_token/', header:&#123;'content-type': 'application/json'&#125;, &#125;).then((res) =&gt; &#123; this.globalData.qiniuToken = res.data.token &#125;);&#125; 导入七牛云文件import qiniuyun from &#39;@/utils/qiniuUploader&#39; base.js代码： 1234567891011121314// 上传图片 base.jsconst uploadImg = (imageURL, uptokenURL) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; qiniuyun.upload(imageURL, (res) =&gt; &#123; resolve(res); &#125;, (error) =&gt; &#123; reject(error); &#125;, &#123; region: 'ECN', domain: '填入域名', uptoken: uptokenURL &#125;); &#125;); &#125; 页面结构 12345678910111213141516&lt;!-- 上传生活照 --&gt; &lt;view class=\"baseInfoTip\" style=\"border: 0\"&gt;上传生活照 &lt;view class=\"imgUploadText\"&gt;(最多9张)&lt;/view&gt; &lt;view class=\"leftOriginLine\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"uploadImgBox\"&gt; &lt;repeat for=\"&#123;&#123;images&#125;&#125;\" index=\"index\" item=\"item\" key=\"index\"&gt; &lt;view class=\"itemBox\"&gt; &lt;image class=\"imgItem\" src=\"&#123;&#123;item&#125;&#125;\" mode=\"aspectFill\"&gt;&lt;/image&gt; &lt;image class=\"imgItemCancel\" id=\"&#123;&#123;index&#125;&#125;\" src=\"../images/common/icon_cardImg_cancel.png\" @tap.stop=\"cancelUploadImg\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/repeat&gt; &lt;view class=\"itemBox\" @tap=\"addImg\" wx:if=\"&#123;&#123;!addImgCtrl&#125;&#125;\"&gt; &lt;image class=\"imgItem\" src=\"../images/common/icon_addImg.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; 上传图片业务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 从相册选择照片上传addImg()&#123; const that = this; if( that.buttonClicked === false ) return; that.buttonClicked = false; wepy.chooseImage(&#123; count:9 - that.images.length, sizeType: 'compressed', &#125;).then(async(res1) =&gt; &#123; that.buttonClicked = true; that.toast('上传图片中...','loading'); let filePath = res1.tempFilePaths; for(let i = 0;i &lt; filePath.length;i++)&#123; let imgSrc= res1.tempFilePaths[i]; let imgType = imgSrc.substring(imgSrc.length-3); let imgSize = res1.tempFiles[i].size; if(imgSize &gt; 2000000 || imgType === 'gif')&#123; that.toast('该图片格式错误！请重新选择一张', 'none', 3000); continue &#125; let res = await base.uploadImg(filePath[i], that.$parent.globalData.qiniuToken); that.images.push(res.imageURL); log('image长度：', that.images.length) log('image：', that.images) if( that.images.length &gt;= 9) &#123; that.addImgCtrl = true &#125; if(that.images.length &gt; 9)&#123; that.images = that.images.slice(0,9) &#125; if(that.images.length &gt;0 &amp;&amp; that.config.fImages)&#123; that.config.progress = that.config.progress + parseFloat(that.config.getConfigs.lifepicweight*100); that.config.fImages = false &#125; that.$apply(); // 上传用户头像列表 that.userInfo.photos = that.images if(i === filePath.length -1)&#123; wepy.hideToast(); &#125; &#125; &#125;).catch((res) =&gt; &#123; if(res.errMsg === \"chooseImage:fail:system permission denied\")&#123; that.toast('请打开微信调用摄像头的权限', 'none', 3500) &#125; &#125;)&#125;,// 取消图片上传cancelUploadImg(e) &#123; if( this.images.length &lt; 10 ) &#123; this.addImgCtrl = false &#125; let index = e.target.id this.images.splice(index, 1)&#125;, 待更新…….","categories":[],"tags":[]},{"title":"firstBlog","slug":"firstBlog","date":"2019-08-19T07:02:47.000Z","updated":"2019-08-19T07:24:07.104Z","comments":true,"path":"2019/08/19/firstBlog/","link":"","permalink":"http://yoursite.com/2019/08/19/firstBlog/","excerpt":"","text":"#既昨天搞崩GitHub博客，再次坚强的尝试 既昨天搞崩GitHub博客，再次坚强的尝试既昨天搞崩GitHub博客，再次坚强的尝试####既昨天搞崩GitHub博客，再次坚强的尝试 #####既昨天搞崩GitHub博客，再次坚强的尝试 1alert('hello world')","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T03:35:44.767Z","updated":"2019-08-19T03:35:44.767Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}